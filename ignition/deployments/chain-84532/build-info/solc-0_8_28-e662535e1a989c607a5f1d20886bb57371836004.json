{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-e662535e1a989c607a5f1d20886bb57371836004",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/chainlink_permit2.sol": "project/contracts/chainlink_permit2.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [],
      "viaIR": true
    },
    "sources": {
      "project/contracts/chainlink_permit2.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n// Interface for OFT bridge functionality\ninterface IOFT {\n    /// @notice Struct for sending parameters\n    struct SendParam {\n        uint32 dstEid;\n        bytes32 to;\n        uint256 amountLD;\n        uint256 minAmountLD;\n        bytes extraOptions;\n        bytes composeMsg;\n        bytes oftCmd;\n    }\n\n    /// @notice Struct for messaging fee\n    struct MessagingFee {\n        uint256 nativeFee;\n        uint256 lzTokenFee;\n    }\n\n    /// @notice Send tokens cross-chain\n    function send(\n        SendParam calldata _sendParam,\n        MessagingFee calldata _fee,\n        address _refundAddress\n    ) external payable returns (MessagingReceipt memory msgReceipt, OFTReceipt memory oftReceipt);\n\n    /// @notice Quote for sending tokens\n    function quoteSend(\n        SendParam calldata _sendParam,\n        bool _payInLzToken\n    ) external view returns (MessagingFee memory msgFee);\n\n    /// @notice ERC20 approve\n    function approve(address spender, uint256 amount) external returns (bool);\n    \n    /// @notice ERC20 balanceOf\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @notice Receipt from messaging\n    struct MessagingReceipt {\n        bytes32 guid;\n        uint64 nonce;\n        MessagingFee fee;\n    }\n\n    /// @notice Receipt from OFT transfer\n    struct OFTReceipt {\n        uint256 amountSentLD;\n        uint256 amountReceivedLD;\n    }\n}\n\n/// @notice Interfaz correcta de AllowanceTransfer (Permit2) según Uniswap\ninterface IAllowanceTransfer {\n    struct PermitDetails {\n        address token;\n        uint160 amount;\n        uint48 expiration;\n        uint48 nonce;\n    }\n\n    struct PermitSingle {\n        PermitDetails details;\n        address spender;\n        uint256 sigDeadline;\n    }\n\n    function permit(\n        address owner,\n        PermitSingle calldata permitSingle,\n        bytes calldata signature\n    ) external;\n\n    function transferFrom(\n        address from,\n        address to,\n        uint160 amount,\n        address token\n    ) external;\n}\n\n/// @notice Interface for Permit2 SignatureTransfer (gasless, no approve needed)\ninterface ISignatureTransfer {\n    struct TokenPermissions {\n        address token;\n        uint256 amount;\n    }\n\n    struct PermitTransferFrom {\n        TokenPermissions permitted;\n        uint256 nonce;\n        uint256 deadline;\n    }\n\n    struct SignatureTransferDetails {\n        address to;\n        uint256 requestedAmount;\n    }\n\n    /// @notice Transfer tokens using a signed permit (no prior approve needed)\n    function permitTransferFrom(\n        PermitTransferFrom calldata permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes calldata signature\n    ) external;\n}\n\n/// @notice Valida firmas Permit2 sin transferir tokens\ncontract Permit2TransferValidator {\n    /// @notice Dirección oficial de Permit2\n    IAllowanceTransfer public constant PERMIT2 =\n        IAllowanceTransfer(0x000000000022D473030F116dDEE9F6B43aC78BA3);\n    \n    /// @notice SignatureTransfer interface (same address as Permit2)\n    ISignatureTransfer public constant PERMIT2_SIGNATURE =\n        ISignatureTransfer(0x000000000022D473030F116dDEE9F6B43aC78BA3);\n\n    event PermitValidated(\n        address indexed owner,\n        address indexed token,\n        address indexed spender,\n        uint160 amount\n    );\n\n    event TokensTransferred(\n        address indexed from,\n        address indexed to,\n        address indexed token,\n        uint160 amount\n    );\n\n    event TokensBridged(\n        address indexed from,\n        address indexed token,\n        uint32 indexed dstEid,\n        address dstAddress,\n        uint256 amount,\n        bytes32 messageId\n    );\n\n    /**\n     * @notice Valida la firma Permit2 sin transferir tokens\n     * @param permitSingle Datos del permiso (AllowanceTransfer)\n     * @param signature Firma EIP-712 del owner\n     * @param owner Dirección que firmó\n     */\n    function validatePermit(\n        IAllowanceTransfer.PermitSingle calldata permitSingle,\n        bytes calldata signature,\n        address owner\n    ) external {\n        // Llamada externa al contrato Permit2 desplegado (0x000000000022D473030F116dDEE9F6B43aC78BA3)\n        // La función permit() del contrato Permit2 valida la firma EIP-712, verifica nonce/expiración\n        // y registra el allowance. Si la firma es inválida, esta llamada revertirá.\n        PERMIT2.permit(owner, permitSingle, signature);\n\n        emit PermitValidated(\n            owner,\n            permitSingle.details.token,\n            permitSingle.spender,\n            permitSingle.details.amount\n        );\n    }\n\n    /**\n     * @notice Validates Permit2 signature and transfers tokens from owner to recipient\n     * @param permitSingle Permit data (AllowanceTransfer)\n     * @param signature EIP-712 signature from owner\n     * @param owner Address that signed\n     * @param recipient Address that will receive the tokens\n     * @param amount Amount to transfer (must be <= permitSingle.details.amount)\n     */\n    function validatePermitAndTransfer(\n        IAllowanceTransfer.PermitSingle calldata permitSingle,\n        bytes calldata signature,\n        address owner,\n        address recipient,\n        uint160 amount\n    ) external {\n        require(recipient != address(0), \"Invalid recipient\");\n        require(recipient != address(this), \"Cannot transfer to self\");\n        require(amount > 0, \"Zero amount\");\n        require(\n            amount <= permitSingle.details.amount,\n            \"Amount exceeds permitted\"\n        );\n        require(\n            permitSingle.details.token != address(0),\n            \"Invalid token\"\n        );\n        require(\n            permitSingle.spender == address(this),\n            \"Invalid spender\"\n        );\n\n        // 1. Validate signature via Permit2 (registers allowance if valid)\n        // Note: This will set/update the allowance in Permit2, but since we transfer\n        // immediately after, the allowance will be consumed and won't accumulate\n        PERMIT2.permit(owner, permitSingle, signature);\n\n        // 2. Transfer tokens from owner to recipient using Permit2\n        // This consumes from the allowance we just set, so it doesn't accumulate\n        PERMIT2.transferFrom(\n            owner,\n            recipient,\n            amount,\n            permitSingle.details.token\n        );\n\n        emit TokensTransferred(\n            owner,\n            recipient,\n            permitSingle.details.token,\n            amount\n        );\n    }\n\n    /**\n     * @notice Validates Permit2 signature and transfers tokens to this contract\n     * @dev This function is used to receive tokens before bridging to another chain\n     * @param permitSingle Permit data (AllowanceTransfer)\n     * @param signature EIP-712 signature from owner\n     * @param owner Address that signed\n     * @param amount Amount to transfer (must be <= permitSingle.details.amount)\n     */\n    function receiveTokensWithPermit(\n        IAllowanceTransfer.PermitSingle calldata permitSingle,\n        bytes calldata signature,\n        address owner,\n        uint160 amount\n    ) external {\n        require(amount > 0, \"Zero amount\");\n        require(\n            amount <= permitSingle.details.amount,\n            \"Amount exceeds permitted\"\n        );\n        require(\n            permitSingle.details.token != address(0),\n            \"Invalid token\"\n        );\n        require(\n            permitSingle.spender == address(this),\n            \"Invalid spender\"\n        );\n\n        // 1. Validate signature via Permit2\n        PERMIT2.permit(owner, permitSingle, signature);\n\n        // 2. Transfer tokens from owner to this contract\n        PERMIT2.transferFrom(\n            owner,\n            address(this),\n            amount,\n            permitSingle.details.token\n        );\n\n        emit TokensTransferred(\n            owner,\n            address(this),\n            permitSingle.details.token,\n            amount\n        );\n    }\n\n    /**\n     * @notice Validates Permit2 signature, receives tokens, and bridges them via LayerZero\n     * @dev This is the main function for gasless cross-chain transfers\n     * @param permitSingle Permit data (AllowanceTransfer)\n     * @param signature EIP-712 signature from owner\n     * @param owner Address that signed the permit\n     * @param amount Amount to transfer and bridge\n     * @param dstEid Destination chain endpoint ID (LayerZero)\n     * @param dstAddress Recipient address on destination chain\n     * @param minAmountLD Minimum amount to receive on destination (slippage protection)\n     * @param extraOptions LayerZero execution options (gas limits, etc)\n     */ \n    function receiveAndBridge(\n        IAllowanceTransfer.PermitSingle calldata permitSingle,\n        bytes calldata signature,\n        address owner,\n        uint160 amount,\n        uint32 dstEid,\n        address dstAddress,\n        uint256 minAmountLD,\n        bytes calldata extraOptions\n    ) external payable {\n        require(amount > 0, \"Zero amount\");\n        require(dstAddress != address(0), \"Invalid destination address\");\n        require(\n            amount <= permitSingle.details.amount,\n            \"Amount exceeds permitted\"\n        );\n        require(\n            permitSingle.details.token != address(0),\n            \"Invalid token\"\n        );\n        require(\n            permitSingle.spender == address(this),\n            \"Invalid spender\"\n        );\n\n        // 1. Validate signature and transfer tokens to this contract\n        PERMIT2.permit(owner, permitSingle, signature);\n        PERMIT2.transferFrom(\n            owner,\n            address(this),\n            amount,\n            permitSingle.details.token\n        );\n\n        emit TokensTransferred(\n            owner,\n            address(this),\n            permitSingle.details.token,\n            amount\n        );\n\n        // 2. Bridge tokens via LayerZero (using scope to reduce stack depth)\n        {\n            IOFT oft = IOFT(permitSingle.details.token);\n            \n            // Approve OFT contract to spend/burn tokens\n            oft.approve(permitSingle.details.token, amount);\n            \n            // Send via LayerZero OFT\n            bytes32 guid = _sendViaLayerZero(\n                oft,\n                dstEid,\n                dstAddress,\n                amount,\n                minAmountLD,\n                extraOptions,\n                owner,\n                msg.value\n            );\n\n            emit TokensBridged(\n                owner,\n                permitSingle.details.token,\n                dstEid,\n                dstAddress,\n                amount,\n                guid\n            );\n        }\n    }\n\n    /**\n     * @notice GASLESS: Validates Permit2 signature, receives tokens, and bridges them via LayerZero\n     * @dev Uses SignatureTransfer - NO PRIOR APPROVE NEEDED! Fully gasless for user.\n     * @param permit Permit data (SignatureTransfer)\n     * @param owner Address that signed the permit\n     * @param signature EIP-712 signature from owner\n     * @param dstEid Destination chain endpoint ID (LayerZero)\n     * @param dstAddress Recipient address on destination chain\n     * @param minAmountLD Minimum amount to receive on destination (slippage protection)\n     * @param extraOptions LayerZero execution options (gas limits, etc)\n     */\n    function receiveAndBridgeGasless(\n        ISignatureTransfer.PermitTransferFrom calldata permit,\n        address owner,\n        bytes calldata signature,\n        uint32 dstEid,\n        address dstAddress,\n        uint256 minAmountLD,\n        bytes calldata extraOptions\n    ) external payable {\n        require(permit.permitted.amount > 0, \"Zero amount\");\n        require(dstAddress != address(0), \"Invalid destination address\");\n        require(permit.permitted.token != address(0), \"Invalid token\");\n\n        uint256 amount = permit.permitted.amount;\n\n        // 1. Transfer tokens directly from owner to this contract using SignatureTransfer\n        // NO PRIOR APPROVE NEEDED!\n        PERMIT2_SIGNATURE.permitTransferFrom(\n            permit,\n            ISignatureTransfer.SignatureTransferDetails({\n                to: address(this),\n                requestedAmount: amount\n            }),\n            owner,\n            signature\n        );\n\n        emit TokensTransferred(owner, address(this), permit.permitted.token, uint160(amount));\n\n        // 2. Bridge tokens to destination chain via LayerZero OFT\n        {\n            IOFT oft = IOFT(permit.permitted.token);\n\n            // Approve OFT to spend tokens from this contract\n            oft.approve(address(oft), amount);\n\n            bytes32 messageId = _sendViaLayerZero(\n                oft,\n                dstEid,\n                dstAddress,\n                amount,\n                minAmountLD,\n                extraOptions,\n                owner, // Refund address\n                msg.value // Native fee\n            );\n\n            emit TokensBridged(owner, permit.permitted.token, dstEid, dstAddress, amount, messageId);\n        }\n    }\n\n    /**\n     * @notice Internal helper to send via LayerZero (reduces stack depth)\n     */\n    function _sendViaLayerZero(\n        IOFT oft,\n        uint32 dstEid,\n        address dstAddress,\n        uint256 amount,\n        uint256 minAmountLD,\n        bytes calldata extraOptions,\n        address refundAddress,\n        uint256 nativeFee\n    ) internal returns (bytes32) {\n        // Prepare SendParam\n        IOFT.SendParam memory sendParam = IOFT.SendParam({\n            dstEid: dstEid,\n            to: bytes32(uint256(uint160(dstAddress))),\n            amountLD: amount,\n            minAmountLD: minAmountLD,\n            extraOptions: extraOptions,\n            composeMsg: \"\",\n            oftCmd: \"\"\n        });\n\n        // Prepare fee\n        IOFT.MessagingFee memory fee = IOFT.MessagingFee({\n            nativeFee: nativeFee,\n            lzTokenFee: 0\n        });\n\n        // Send\n        (IOFT.MessagingReceipt memory msgReceipt, ) = oft.send{value: nativeFee}(\n            sendParam,\n            fee,\n            refundAddress\n        );\n\n        return msgReceipt.guid;\n    }\n\n    /**\n     * @notice Quote the fee for bridging tokens via LayerZero\n     * @param token OFT token address\n     * @param dstEid Destination chain endpoint ID\n     * @param dstAddress Recipient address on destination chain\n     * @param amount Amount to bridge\n     * @param minAmountLD Minimum amount (for slippage)\n     * @param extraOptions LayerZero execution options\n     * @return nativeFee Required fee in native token\n     */\n    function quoteBridge(\n        address token,\n        uint32 dstEid,\n        address dstAddress,\n        uint256 amount,\n        uint256 minAmountLD,\n        bytes calldata extraOptions\n    ) external view returns (uint256 nativeFee) {\n        IOFT oft = IOFT(token);\n        \n        bytes32 toAddress = bytes32(uint256(uint160(dstAddress)));\n        IOFT.SendParam memory sendParam = IOFT.SendParam({\n            dstEid: dstEid,\n            to: toAddress,\n            amountLD: amount,\n            minAmountLD: minAmountLD,\n            extraOptions: extraOptions,\n            composeMsg: \"\",\n            oftCmd: \"\"\n        });\n\n        IOFT.MessagingFee memory fee = oft.quoteSend(sendParam, false);\n        return fee.nativeFee;\n    }\n\n    /**\n     * @notice Withdraw tokens from contract (emergency or after receiving)\n     * @param token Token address\n     * @param to Recipient address\n     * @param amount Amount to withdraw\n     */\n    function withdrawTokens(\n        address token,\n        address to,\n        uint256 amount\n    ) external {\n        require(msg.sender == address(this) || to == msg.sender, \"Not authorized\");\n        IOFT oft = IOFT(token);\n        require(oft.balanceOf(address(this)) >= amount, \"Insufficient balance\");\n        oft.approve(to, amount);\n        // Transfer would need to be done by the token contract\n    }\n}\n"
      }
    }
  }
}